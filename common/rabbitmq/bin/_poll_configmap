#!/usr/bin/env python3
from pathlib import Path
from urllib.request import Request, urlopen
from urllib.parse import urlencode
from urllib.error import HTTPError
import os
import ssl
import signal
import sys
import tempfile
import time
import json
import logging
import subprocess

LOG = logging.getLogger(__name__)
SCRIPT_PATH = Path(sys.argv[0])


def sigterm_handler(_signo, _stack_frame):
    sys.exit(0)


def request(**params):
    apiserver = "https://kubernetes.default.svc"
    serviceaccount_path = Path("/run/secrets/kubernetes.io/serviceaccount")

    with (serviceaccount_path / "namespace").open() as f:
        namespace = f.read()
    with (serviceaccount_path / "token").open() as f:
        token = f.read()

    cacert = serviceaccount_path / "ca.crt"
    context = ssl.create_default_context(cafile=cacert)

    req = Request(url=f"{apiserver}/api/v1/namespaces/{namespace}/configmaps/?{urlencode(params)}")
    req.add_header("Authorization", f"Bearer {token}")
    req.add_header("Accept", "application/json")

    with urlopen(req, context=context) as response:
        for line in response:
            yield json.loads(line)


def execute(to_execute):
    for key in sorted(to_execute):
        LOG.info("Executing %s", key)
        os.chmod(key, 0o750)
        subprocess.check_call([f"./{key}"], shell=True)
        LOG.info("Executed %s", key)


def process(cm, resource_version):
    to_execute = []
    restart_self = False
    for key, data in cm.items():
        old = Path(key)
        oldcontent = None
        try:
            with old.open("r") as f:
                oldcontent = f.read()
                if oldcontent == data:
                    LOG.debug("Skipping %s", key)
                    continue
            new = Path(f".{key}")
        except FileNotFoundError:
            new = old
        with new.open("w") as n:
            n.write(data)
            os.fsync(n)
            LOG.debug("Written %s", new)
            if key[0] != "_" and data.startswith("#!"):
                to_execute.append(key)
            if key == SCRIPT_PATH.name and oldcontent:
                restart_self = True
        if old != new:
            os.replace(new, old)

    if not restart_self:
        execute(to_execute)
        return resource_version

    replacement = Path.cwd() / SCRIPT_PATH.name
    LOG.info("Restarting %s %s", replacement, resource_version)
    os.sync()
    os.execvp("/usr/bin/env", ["/usr/bin/env", "python3", replacement, sys.argv[1], resource_version, *to_execute])


def startup(field_selector):
    data = next(request(fieldSelector=field_selector))
    return process(data["items"][0]["data"], data["metadata"]["resourceVersion"])


def main():
    LOG.debug("Started script 2 %s", SCRIPT_PATH)
    signal.signal(signal.SIGTERM, sigterm_handler)

    if len(sys.argv) < 2:
        LOG.error("Need field-selector as argument")
        return 1
    field_selector = sys.argv[1]

    if len(sys.argv) == 2:
        resource_version = startup(field_selector)
    else:
        resource_version = sys.argv[2]
        execute(sys.argv[3:])

    while True:
        try:
            for data in request(fieldSelector=field_selector, watch=1, resourceVersion=resource_version):
                obj = data["object"]
                resource_version = process(obj["data"], obj["metadata"]["resourceVersion"])
        except HTTPError:
            time.sleep(1)
            LOG.exception("HTTPError while polling")
        except OSError:
            LOG.exception("OSError while polling")
    return 0


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG, format="%(asctime)s %(process)d %(levelname)s %(name)s %(message)s")
    sys.exit(main())
